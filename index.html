<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vite App</title>
  </head>
  <body>
    <div id="app"></div>
    <div id="destination"></div>
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

<!--
SPA : Single Page Application
 -> 하나의 html에 다수의 컴포넌트가 연결되는 형태.
 -> 상시 ajax(상시 비동기)
 -> react, vue나오면서 각광받은 방식
 -> 서버로부터 데이터만 요청하고 받아온후 클라이언트에서 그리는 CSR방식을 추구.
 ->  (모든 html/css/js 요소를 전부 땡겨온후 비동기 통신을 통해서 데이터만 받아오는 방법)

장점 : 부드러운 화면전환(사용자입장에서 부드러워보인다.)
      연산의 분산화를 통한 서버의 부담을 줄일수 있음.
      생산성 향상. -> 컴포넌트 별로 개발이 진행되는점.
      디바이스 에서도 동일하게 쓸수 있다는점.(서버의 API화)

단점 : 검색엔진 인덱스화가 난해함, 비쌈


MPA : Multi Page Application
 -> 바닐라 js할때는 이렇게했음.
 -> ajax, axios등으로비동기를 처리하는게 아니라면 기본적으로는 동기방식
 -> SSR(Server Side Rendering) : 전통적인 웹의 동작 방식.

장,단점 : SPA 리버스.(SPA의 단점이 MPA 장점, SPA 장점 MPA 단점)


SFC와 컴포넌트

컴포넌트 : 재사용이 가능한 각각의 독립된 모듈.(코드덩어리)
 -> SPA 방식에서는 컴포넌트를 어떻게 조합하느냐가 프로젝트의 성패.
 -> 컴포넌트 중심의 개발방식을 통해 코드의 재사용성과 생산성을 높일수 있음.
    (유지보수성은 글쎄요)

SFC (Single File Component): 파일 하나가 하나의 컴포넌트를 구성한다.
 -> .vue라는 파일에 template, script, style 3개의 태그를 이용하여 컴포넌트를 구성한다.
 -> .vue파일은 어차피 브라우저가 못읽기 때문에 읽을수 있도록 컴파일이 필요
     그것을 처리해주는것이 Vite(과거에는 Vue CLI)

// 필터링된 할일 목록
// filter함수 : Arrays.filter()
//  배열의 각 요소를 순회하면서 주어진 조건에 맞는 요소만을 모아서
//  새로운 배열을 만들어내는 함수.

// splice가 비슷한데 둘중 누가더 좋은가?
// splice : 빠르고 메모리 효율상으로 우수.
// filter : 원본 유지, 특히나 객체 배열에서 조건별로 뽑아낼때 유리.

// 선택기준
// 값이 단순 배열일수록 splice가 유리, 성능이 중시되는 상황일수록 splice가 유리
// 객체타입(key:val)거나 원본의 배열을 유지하고 싶다면 filter를 사용

// refs : 배열을 반응형으로 변경.(HTMLCollection 화)
// scoped : css 범위 조정
//  -> css의 범위가 해당 컴포넌트를 벗어나지 못하도록 처리할때 사용하는 키워드.
//  -> react vue에서 자주사용(컴포넌트단위의 약점은 css가 겹치기 쉬움.)
//     const todos = [
//         { id: 1, text: '할일 1' },
//         { id: 2, text: '할일 2' },
//         { id: 3, text: '할일 3' }
// ]

    // id가 2인 항목 제거
// const resultTodos = todos.filter(todo => todo.id == 2)
    // 결과: [{ id: 1, text: '할일 1' }, { id: 3, text: '할일 3' }]

vue setup
 -> 기존에 흩어진 data, method를 하나의 장소로 모아주는 메서드.

Vue Props
부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 특별한 속성
html 요소의 속성처럼 작동하는것 같음 하지만 어떤 js값이든 전달 가능.
v-bind 혹은 : 키워드를 통해 데이터를 전달하고 자식컴포넌트에서 props를 통해
데이터를 전달 받는 방식.

props는 단순하게 문자열로만 쓰는것은 아님.
 -> 객체 타입등 다양한 방법으로 데이터를 받아온후 처리


$emit() 메서드
 -> 자식컴포넌트에서 부모 컴포넌트로 데이터를 전달하거나 
    혹은 트리거의 목적으로 이벤트를 내보내는 기능을 담당하는 메서드
 -> 부모요소에서 캡처할수있는 자식 구성 요소중 사용자 정의 이벤트를
    만드는 메서드.

SFC와 스타일링(style scoped)
 -> 전역과 컴포넌트 스타일링.
 -> SFC의 경우는 하나의파일에서 작업.
 -> .vue 파일을 브라우저 엔진이 바로 해석 가능한가?
    (최종적으로 html로 변환.)
 -> <style>부분은 만약 여러개의 컴포넌트를 불러올때는 문제가 발생할수 있음.
    (스타일 중복적용 현상 발생 가능성)

  vue에서는 컴포넌트구성시 style 옆에 scoped라는 키워드를 작성하여
  범위를 해당 컴포넌트 내부로만 제한할수 있음.
  (CSS 고립)

  지역 컴포넌트, 전역 컴포넌트

  전역컴포넌트 : 여러 인스턴스에서 공통으로 사용가능한 컴포넌트
   -> vue 생성자에서 호출가능한 컴포넌트
   -> 한번 등록하면 어느 인스턴스에서나 사용가능
  지역컴포넌트 : 특정 인스턴스에서만 사용가능한 컴포넌트.
   -> 새 인스턴스를 생성할때마다 등록해야함.

   슬롯 : 특정한 컴포넌트에서 자신에게 등록된 자식 컴포넌트의 내용을 재정의하는 개념
    -> 컴포넌트의 재사용성의 극대화

  동적 컴포넌트 : 원하는 컴포넌트를 불러올때 사용하는 개념.
  - 컴포넌트를 필요한 것들만 불러오기 때문에 SPA의 약점을 어느정도는 커버할수 있음.
  - 메모리관리, 유지보수 측면에서도 유리한 개념.
  - 동적컴포넌트는 is라는 속성값을 활용하여 처리.

  텔레포트(react에서는 portal)
    - vue, react나 나온 이유중 하나는 재사용성의 극대화를 노리고 나온거.
    - 기능이 많아질수록 그리고 프로젝트의 구조가 복잡해질수록 
      바닐라js보다 재사용성이 떨어지는 결과가 나올떄도 있었음.
    - 랜더링된 컴포넌트에 따라 띄우는 모달의 스크립트나 css를 각각 따로 작업하면
      그냥 원래대로 하는게 더 편함.
    - 그래서 나온것이 teleport(portal)
      (index에 div id=app과 같은 레벨의 별도의 div을 생성 한후 
        새롭게 추가된 div에 나머지 컴포넌트를 불러온다.)
    - 요약하자면 DOM구조에서 다른위치로 컨텐츠 이동시 사용하는 개념.

    Http 통신
     - 기존 : 
    async function test(){
      const api = await fetch("주소오오오오")
    } 
    vue에서도 ajax같은 비동기 전송방식을 지원하는 라이브 러리도 있음.
     - vue resource, axios
            // fetch는 기본적으로 promise 기반의 메서드이기때문에
            // 리턴타입 또한 프로미스타입.
            //  fetch() 메서드가 제공하는 첫번째 리턴은
            // Http 요청이 전송되었음을 의미하는 객체일뿐.
            // 즉 요청만 받아온 경우는 보류상태...

    vue 라우터 : express의 라우터와 거의 유사
     - 뷰에서 라우팅 기능을 제공해주는 라이브러리
       (브라우저가 새로고침없이 뷰로 만든 페이지간 자유로운 이동을 지원.) 
    vue 라이프 사이클 
     - 컴포넌트가 생성-업데이트-제거되는 과정 자체를 관리하는 메서드
     - Creation, Mounting, Updating, Destruction
     - 크게 4가지 상태로 구분되면서 인스턴스의 주기별로 행동을 제어한다.
    
    Hook : 컴포넌트의 라이프사이클에서 특정단계에 끼어들수 있는 메서드.
     - Vue의 경우는 라이프사이클별로 단계마다 제어할수 있도록 메서드를 준비해둠
    
    그렇다면 라이프사이클을 이용했을때의 장점은?
     - 상태별로 메서드가 정해져 있기 때문에 네이밍 고민이 필요없음.
     - 즉 어느 개발자나 똑같은 상태별 처리가 가능하기때문에 유지보수성 또한 좋아짐.

    1. beforeCreate : 구성요소 초기화 전에 실행되는 메서드
     - Vue 인스턴스가 구성요소의 데이터, 계산된 속성, 메서드 및 이벤트 리스너를 설정하기 전.
     주의사항 : DOM요소에 엑세스 불가.
       - 그 외에 객체 생성 이전 이벤트다 보니 객체 생성이후 이벤트들에는 접근 불가.
     - 글로벌 이벤트 리스너 설정시 사용.
    2. created (-) : DOM에 접근 가능한 초기 데이터 값 설정시 사용하는 메서드.
    3. beforeMount : 초기 렌더링 직전에 실행.
    4. mounted (-) : 컴포넌트 자체가 DOM에 추가되는 단계.
        - DOM에 컴포넌트가 마운트 된 후 실행.
    5. beforeUpdate : 데이터가 변경될때마다 호출되지만 업데이트가 화면에 렌더링 되기 전에 호출.
        - 무한 루프에 빠지기 쉬운 메서드(훅).
    6. updated (-) : 업데이트가 화면에 렌더링 된 후 호출.
        - 컴포넌트의 반응형 데이터가 변경되어 재랜더링이 발생하는 단계
    - beforeUpdate와 updated의 실행 주기 차이는 화면에 렌더링 되기 전이냐 후냐
      차이라고보면됨.
    - 공통점은 어떤 이벤트가 수행됐을때 실행되는 공통점이 있음.
    
    7. beforeUnmount (-)
    8. unmounted (-)
    9. errorCaptured : 오류 발생시 호출되는 메서드
    10. renderTracked : vue3에 출시된 메서드(훅)
     - 컴포넌트의 렌더링 과정을 추적하고 최적화 하는데 도움주는 훅.
     - beforeUpdate, updated와 같이 연계되서 사용,
     - 성능에 영향을 주기때문에 개발과정에서만 사용하고 운영과정에서는 제외할것.
    11. renderTriggered : 렌더링 과정이 완료된 후 실행되는 훅
     - 컴포넌트 렌더링 후에 필요한 작업을 수행하거나 렌더링 결과를 확인할수 있음.
    12. activated : mounted와 비슷.
     - 보관하고 있는 구성요소가 활성화 될시 호출
    13. deactivated : 보관하고 있는 구성요소가 비활성화 될시 호출
    14. serverPreFetch : SSR 환경에서 사용하는 비동기 함수.
     - 라우팅과 관련되어있는 함수.


     Creation(생성) 단계
      - 컴포넌트가 DOM에 추가되기 전 실행
      - 서버사이드 렌더링에서도 실행되는 단계(유일한 훅)

-->
